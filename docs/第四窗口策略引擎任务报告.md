# çª—å£4: ç­–ç•¥å¼•æ“ä¸“å®¶ä»»åŠ¡æ¸…å•
## Strategy Engine Service ä¸“ä¸šå¼€å‘

**è§’è‰²**: ç­–ç•¥å¼•æ“å·¥ç¨‹å¸ˆ  
**ä¸“æ³¨æœåŠ¡**: Strategy Engine Service (ç«¯å£8083)  
**æ ¸å¿ƒæŠ€èƒ½**: Rust + é‡åŒ–ç®—æ³• + æ•°å­¦å»ºæ¨¡  

---

## ğŸ¯ **æœåŠ¡èŒè´£**

### **æ ¸å¿ƒåŠŸèƒ½**
- é‡åŒ–ç­–ç•¥æ¡†æ¶è®¾è®¡
- æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å¼•æ“
- å›æµ‹å’Œæ€§èƒ½åˆ†æ
- å®æ—¶ä¿¡å·ç”Ÿæˆ
- ç­–ç•¥å‚æ•°ä¼˜åŒ–

### **æŠ€æœ¯æ ˆ**
- **è¯­è¨€**: Rust (æ•°å€¼è®¡ç®—ä¼˜åŒ–)
- **ç®—æ³•**: æŠ€æœ¯åˆ†æ + ç»Ÿè®¡æ¨¡å‹
- **æ•°æ®**: å†å²æ•°æ® + å®æ—¶æ•°æ®
- **å­˜å‚¨**: PostgreSQL + ClickHouse
- **ç›‘æ§**: ç­–ç•¥æ€§èƒ½æŒ‡æ ‡

---

## ğŸ“‹ **ä»Šæ—¥ä»»åŠ¡ (P0ä¼˜å…ˆçº§)**

### **1. ç­–ç•¥æ¡†æ¶æ ¸å¿ƒè®¾è®¡ (9:00-13:00)** ğŸ§ 
**ç›®æ ‡**: å»ºç«‹å¯æ‰©å±•çš„ç­–ç•¥æ’ä»¶ç³»ç»Ÿ

**æ ¸å¿ƒæ–‡ä»¶**:
```rust
22/services/strategy-engine/src/services/strategy_service.rs
22/services/strategy-engine/src/models/strategy.rs
22/services/strategy-engine/src/handlers/strategies.rs
```

**å®ç°è¦æ±‚**:
- [ ] Strategy trait: ç»Ÿä¸€ç­–ç•¥æ¥å£
- [ ] StrategyManager: ç­–ç•¥ç”Ÿå‘½å‘¨æœŸç®¡ç†
- [ ] SignalGenerator: äº¤æ˜“ä¿¡å·ç”Ÿæˆ
- [ ] PerformanceTracker: ç­–ç•¥æ€§èƒ½è·Ÿè¸ª

### **2. æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å¼•æ“ (13:00-16:00)** ğŸ“Š
**ç›®æ ‡**: é«˜æ€§èƒ½æŠ€æœ¯æŒ‡æ ‡è®¡ç®—

**æŒ‡æ ‡å®ç°**:
- [ ] ç§»åŠ¨å¹³å‡çº¿ (SMA, EMA, WMA)
- [ ] ç›¸å¯¹å¼ºå¼±æŒ‡æ•° (RSI)
- [ ] å¸ƒæ—å¸¦ (Bollinger Bands)
- [ ] MACDæŒ‡æ ‡
- [ ] KDJéšæœºæŒ‡æ ‡

### **3. å›æµ‹å¼•æ“åŸºç¡€ (16:00-18:00)** ğŸ”„
**ç›®æ ‡**: ç­–ç•¥å†å²æ•°æ®éªŒè¯

**åŠŸèƒ½å®ç°**:
- [ ] å†å²æ•°æ®å›æ”¾
- [ ] ç­–ç•¥ä¿¡å·æ¨¡æ‹Ÿ
- [ ] æ€§èƒ½æŒ‡æ ‡è®¡ç®—
- [ ] å›æµ‹æŠ¥å‘Šç”Ÿæˆ

---

## ğŸ”§ **ç­–ç•¥æ¡†æ¶è®¾è®¡**

### **ç­–ç•¥æ¥å£å®šä¹‰**
```rust
#[async_trait]
pub trait Strategy: Send + Sync {
    fn name(&self) -> &str;
    fn version(&self) -> &str;
    fn parameters(&self) -> &StrategyParameters;
    
    // ç­–ç•¥ç”Ÿå‘½å‘¨æœŸ
    async fn initialize(&mut self, context: &StrategyContext) -> Result<()>;
    async fn on_tick(&mut self, tick: &MarketTick) -> Result<Vec<Signal>>;
    async fn on_kline(&mut self, kline: &Kline) -> Result<Vec<Signal>>;
    async fn on_order_update(&mut self, order: &Order) -> Result<()>;
    async fn cleanup(&mut self) -> Result<()>;
}

// ç­–ç•¥ä¸Šä¸‹æ–‡
pub struct StrategyContext {
    pub symbol: String,
    pub timeframe: String,
    pub historical_data: Vec<Kline>,
    pub indicators: IndicatorManager,
    pub risk_manager: RiskManager,
}
```

### **ç­–ç•¥ç®¡ç†å™¨**
```rust
pub struct StrategyManager {
    // æ´»è·ƒç­–ç•¥
    active_strategies: HashMap<String, Box<dyn Strategy>>,
    
    // ç­–ç•¥è°ƒåº¦å™¨
    scheduler: StrategyScheduler,
    
    // æ€§èƒ½è·Ÿè¸ª
    performance_tracker: PerformanceTracker,
    
    // ä¿¡å·è·¯ç”±
    signal_router: SignalRouter,
}

impl StrategyManager {
    pub async fn create_strategy(&mut self, config: StrategyConfig) -> Result<String> {
        // 1. éªŒè¯ç­–ç•¥é…ç½®
        self.validate_config(&config)?;
        
        // 2. åˆ›å»ºç­–ç•¥å®ä¾‹
        let strategy = self.strategy_factory.create(&config)?;
        
        // 3. åˆå§‹åŒ–ç­–ç•¥
        let context = self.build_context(&config).await?;
        strategy.initialize(&context).await?;
        
        // 4. æ³¨å†Œåˆ°ç®¡ç†å™¨
        let strategy_id = Uuid::new_v4().to_string();
        self.active_strategies.insert(strategy_id.clone(), strategy);
        
        Ok(strategy_id)
    }
    
    pub async fn execute_strategy(&self, strategy_id: &str, market_data: MarketData) -> Result<Vec<Signal>> {
        let strategy = self.active_strategies.get_mut(strategy_id)
            .ok_or(StrategyError::NotFound)?;
        
        let signals = match market_data {
            MarketData::Tick(tick) => strategy.on_tick(&tick).await?,
            MarketData::Kline(kline) => strategy.on_kline(&kline).await?,
        };
        
        // è®°å½•æ€§èƒ½
        self.performance_tracker.record_execution(strategy_id, &signals).await?;
        
        Ok(signals)
    }
}
```

### **æŠ€æœ¯æŒ‡æ ‡å¼•æ“**
```rust
pub struct IndicatorManager {
    calculators: HashMap<String, Box<dyn IndicatorCalculator>>,
    cache: IndicatorCache,
}

#[async_trait]
pub trait IndicatorCalculator: Send + Sync {
    fn name(&self) -> &str;
    async fn calculate(&self, data: &[Kline]) -> Result<IndicatorValue>;
    fn required_periods(&self) -> usize;
}

// SMAæŒ‡æ ‡å®ç°
pub struct SMACalculator {
    period: usize,
}

impl IndicatorCalculator for SMACalculator {
    fn name(&self) -> &str { "SMA" }
    
    async fn calculate(&self, data: &[Kline]) -> Result<IndicatorValue> {
        if data.len() < self.period {
            return Err(IndicatorError::InsufficientData);
        }
        
        let sum: Decimal = data.iter()
            .rev()
            .take(self.period)
            .map(|k| k.close)
            .sum();
        
        let sma = sum / Decimal::from(self.period);
        Ok(IndicatorValue::Single(sma))
    }
    
    fn required_periods(&self) -> usize { self.period }
}

// RSIæŒ‡æ ‡å®ç°
pub struct RSICalculator {
    period: usize,
}

impl IndicatorCalculator for RSICalculator {
    async fn calculate(&self, data: &[Kline]) -> Result<IndicatorValue> {
        if data.len() < self.period + 1 {
            return Err(IndicatorError::InsufficientData);
        }
        
        let mut gains = Vec::new();
        let mut losses = Vec::new();
        
        for i in 1..=self.period {
            let change = data[data.len() - i].close - data[data.len() - i - 1].close;
            if change > Decimal::ZERO {
                gains.push(change);
                losses.push(Decimal::ZERO);
            } else {
                gains.push(Decimal::ZERO);
                losses.push(-change);
            }
        }
        
        let avg_gain: Decimal = gains.iter().sum::<Decimal>() / Decimal::from(self.period);
        let avg_loss: Decimal = losses.iter().sum::<Decimal>() / Decimal::from(self.period);
        
        if avg_loss == Decimal::ZERO {
            return Ok(IndicatorValue::Single(Decimal::from(100)));
        }
        
        let rs = avg_gain / avg_loss;
        let rsi = Decimal::from(100) - (Decimal::from(100) / (Decimal::ONE + rs));
        
        Ok(IndicatorValue::Single(rsi))
    }
}
```

---

## ğŸ“Š **ä¿¡å·ç”Ÿæˆç³»ç»Ÿ**

### **äº¤æ˜“ä¿¡å·æ¨¡å‹**
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    pub id: String,
    pub strategy_id: String,
    pub symbol: String,
    pub signal_type: SignalType,
    pub strength: f64,        // ä¿¡å·å¼ºåº¦ 0.0-1.0
    pub confidence: f64,      // ç½®ä¿¡åº¦ 0.0-1.0
    pub price: Decimal,       // è§¦å‘ä»·æ ¼
    pub timestamp: DateTime<Utc>,
    pub metadata: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SignalType {
    Buy,
    Sell,
    Hold,
    StopLoss,
    TakeProfit,
}
```

### **ä¿¡å·ç”Ÿæˆå™¨**
```rust
pub struct SignalGenerator {
    strategy_id: String,
    rules: Vec<SignalRule>,
}

impl SignalGenerator {
    pub fn generate_signals(&self, context: &StrategyContext) -> Result<Vec<Signal>> {
        let mut signals = Vec::new();
        
        for rule in &self.rules {
            if let Some(signal) = rule.evaluate(context)? {
                signals.push(signal);
            }
        }
        
        // ä¿¡å·è¿‡æ»¤å’Œä¼˜åŒ–
        self.filter_signals(signals)
    }
    
    fn filter_signals(&self, mut signals: Vec<Signal>) -> Result<Vec<Signal>> {
        // 1. å»é‡å¤ä¿¡å·
        signals.dedup_by(|a, b| a.signal_type == b.signal_type);
        
        // 2. æŒ‰å¼ºåº¦æ’åº
        signals.sort_by(|a, b| b.strength.partial_cmp(&a.strength).unwrap());
        
        // 3. é™åˆ¶ä¿¡å·æ•°é‡
        signals.truncate(5);
        
        Ok(signals)
    }
}
```

---

## ğŸ”„ **å›æµ‹å¼•æ“å®ç°**

### **å›æµ‹å¼•æ“æ ¸å¿ƒ**
```rust
pub struct BacktestEngine {
    historical_data: HistoricalDataProvider,
    strategy_runner: StrategyRunner,
    performance_analyzer: PerformanceAnalyzer,
}

impl BacktestEngine {
    pub async fn run_backtest(&self, config: BacktestConfig) -> Result<BacktestReport> {
        // 1. åŠ è½½å†å²æ•°æ®
        let data = self.historical_data.load_data(&config).await?;
        
        // 2. åˆå§‹åŒ–ç­–ç•¥
        let mut strategy = self.strategy_runner.create_strategy(&config.strategy_config)?;
        
        // 3. æ‰§è¡Œå›æµ‹
        let mut portfolio = Portfolio::new(config.initial_capital);
        let mut trades = Vec::new();
        
        for kline in data {
            // ç”Ÿæˆä¿¡å·
            let signals = strategy.on_kline(&kline).await?;
            
            // æ‰§è¡Œäº¤æ˜“
            for signal in signals {
                if let Some(trade) = self.execute_signal(&signal, &kline, &mut portfolio)? {
                    trades.push(trade);
                }
            }
        }
        
        // 4. åˆ†ææ€§èƒ½
        let report = self.performance_analyzer.analyze(&trades, &portfolio)?;
        
        Ok(report)
    }
    
    fn execute_signal(&self, signal: &Signal, kline: &Kline, portfolio: &mut Portfolio) -> Result<Option<Trade>> {
        match signal.signal_type {
            SignalType::Buy => {
                if portfolio.cash > Decimal::ZERO {
                    let quantity = portfolio.cash / kline.close;
                    portfolio.cash -= quantity * kline.close;
                    portfolio.position += quantity;
                    
                    Ok(Some(Trade {
                        id: Uuid::new_v4().to_string(),
                        symbol: signal.symbol.clone(),
                        side: TradeSide::Buy,
                        quantity,
                        price: kline.close,
                        timestamp: kline.close_time,
                    }))
                } else {
                    Ok(None)
                }
            }
            SignalType::Sell => {
                if portfolio.position > Decimal::ZERO {
                    let quantity = portfolio.position;
                    portfolio.cash += quantity * kline.close;
                    portfolio.position = Decimal::ZERO;
                    
                    Ok(Some(Trade {
                        id: Uuid::new_v4().to_string(),
                        symbol: signal.symbol.clone(),
                        side: TradeSide::Sell,
                        quantity,
                        price: kline.close,
                        timestamp: kline.close_time,
                    }))
                } else {
                    Ok(None)
                }
            }
            _ => Ok(None),
        }
    }
}
```

### **æ€§èƒ½åˆ†æå™¨**
```rust
pub struct PerformanceAnalyzer;

impl PerformanceAnalyzer {
    pub fn analyze(&self, trades: &[Trade], portfolio: &Portfolio) -> Result<BacktestReport> {
        let total_return = self.calculate_total_return(trades, portfolio)?;
        let sharpe_ratio = self.calculate_sharpe_ratio(trades)?;
        let max_drawdown = self.calculate_max_drawdown(trades)?;
        let win_rate = self.calculate_win_rate(trades)?;
        
        Ok(BacktestReport {
            total_return,
            annualized_return: total_return * Decimal::from(365) / Decimal::from(trades.len()),
            sharpe_ratio,
            max_drawdown,
            win_rate,
            total_trades: trades.len(),
            profit_factor: self.calculate_profit_factor(trades)?,
            volatility: self.calculate_volatility(trades)?,
        })
    }
    
    fn calculate_total_return(&self, trades: &[Trade], portfolio: &Portfolio) -> Result<Decimal> {
        if trades.is_empty() {
            return Ok(Decimal::ZERO);
        }
        
        let initial_value = trades[0].price * trades[0].quantity;
        let final_value = portfolio.cash + portfolio.position * trades.last().unwrap().price;
        
        Ok((final_value - initial_value) / initial_value * Decimal::from(100))
    }
}
```

---

## ğŸ”Œ **APIæ¥å£å®ç°**

### **ç­–ç•¥ç®¡ç†æ¥å£**
```rust
// GET /api/v1/strategies - è·å–ç­–ç•¥åˆ—è¡¨
pub async fn get_strategies(
    State(app_state): State<AppState>,
) -> Result<Json<StrategiesResponse>, StrategyError> {
    let strategies = app_state.strategy_manager.get_all_strategies().await?;
    Ok(Json(StrategiesResponse {
        strategies,
        total_count: strategies.len() as u32,
    }))
}

// POST /api/v1/strategies - åˆ›å»ºç­–ç•¥
pub async fn create_strategy(
    State(app_state): State<AppState>,
    Json(request): Json<CreateStrategyRequest>,
) -> Result<Json<CreateStrategyResponse>, StrategyError> {
    let strategy_id = app_state.strategy_manager.create_strategy(request.into()).await?;
    Ok(Json(CreateStrategyResponse { strategy_id }))
}

// GET /api/v1/strategies/:id/signals - è·å–ç­–ç•¥ä¿¡å·
pub async fn get_strategy_signals(
    State(app_state): State<AppState>,
    Path(strategy_id): Path<String>,
) -> Result<Json<StrategySignalsResponse>, StrategyError> {
    let signals = app_state.strategy_manager.get_signals(&strategy_id).await?;
    Ok(Json(StrategySignalsResponse { signals }))
}

// POST /api/v1/strategies/:id/backtest - è¿è¡Œå›æµ‹
pub async fn run_backtest(
    State(app_state): State<AppState>,
    Path(strategy_id): Path<String>,
    Json(config): Json<BacktestConfig>,
) -> Result<Json<BacktestReport>, StrategyError> {
    let report = app_state.backtest_engine.run_backtest(config).await?;
    Ok(Json(report))
}
```

---

## ğŸ§ª **æµ‹è¯•è¦æ±‚**

### **ç­–ç•¥æµ‹è¯•**
```rust
#[tokio::test]
async fn test_sma_strategy() {
    let mut strategy = SMAStrategy::new(20, 50);
    let context = create_test_context().await;
    
    strategy.initialize(&context).await.unwrap();
    
    let kline = create_test_kline(100.0);
    let signals = strategy.on_kline(&kline).await.unwrap();
    
    assert!(!signals.is_empty());
    assert_eq!(signals[0].signal_type, SignalType::Buy);
}

#[tokio::test]
async fn test_backtest_performance() {
    let engine = BacktestEngine::new();
    let config = BacktestConfig {
        strategy_config: StrategyConfig::sma_crossover(20, 50),
        symbol: "BTC/USDT".to_string(),
        start_date: Utc::now() - Duration::days(30),
        end_date: Utc::now(),
        initial_capital: Decimal::from(10000),
    };
    
    let report = engine.run_backtest(config).await.unwrap();
    
    assert!(report.total_return > Decimal::from(-50)); // æœ€å¤§äºæŸ50%
    assert!(report.sharpe_ratio > 0.0);
}
```

---

## âœ… **ä»Šæ—¥æˆåŠŸæ ‡å‡†**

### **åŠŸèƒ½å®Œæˆ**
- [ ] ç­–ç•¥æ¡†æ¶æ ¸å¿ƒæ¥å£å®šä¹‰
- [ ] åŸºç¡€æŠ€æœ¯æŒ‡æ ‡å®ç° (SMA, RSI, MACD)
- [ ] ä¿¡å·ç”Ÿæˆç³»ç»Ÿ
- [ ] å›æµ‹å¼•æ“åŸºç¡€åŠŸèƒ½

### **è´¨é‡è¦æ±‚**
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ >80%
- [ ] ç­–ç•¥æ‰§è¡Œæ€§èƒ½ä¼˜åŒ–
- [ ] æ•°å­¦è®¡ç®—å‡†ç¡®æ€§éªŒè¯
- [ ] APIæ¥å£æµ‹è¯•é€šè¿‡

---

**è´Ÿè´£äºº**: Strategy Engine Engineer  
**å®Œæˆæ—¶é—´**: ä»Šæ—¥18:00å‰  
**è´¨é‡æ ‡å‡†**: ç®—æ³•å‡†ç¡®æ€§ + æ€§èƒ½è¾¾æ ‡ + æ¶æ„å¸ˆå®¡æŸ¥é€šè¿‡