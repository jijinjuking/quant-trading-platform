# ğŸ” é‡åŒ–äº¤æ˜“å¹³å°å®Œæ•´å·¥ä½œæµç¨‹å›¾

**æ£€æŸ¥å‘˜**: ç³»ç»Ÿæ¶æ„æ£€æŸ¥å‘˜  
**åˆ†ææ—¶é—´**: 2024å¹´12æœˆ22æ—¥  
**åˆ†æèŒƒå›´**: å‰ç«¯ â†’ åç«¯ â†’ æ•°æ®åº“å®Œæ•´æ•°æ®æµ

---

## ğŸ¯ **ç³»ç»Ÿæ¶æ„æ€»è§ˆ**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ğŸŒ å‰ç«¯å±‚ (Frontend Layer)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Vueç®¡ç†ç«¯        â”‚  Reactç”¨æˆ·ç«¯         â”‚  React Nativeæ‰‹æœºç«¯                  â”‚
â”‚  (22/frontend)    â”‚  (quant-backend66)   â”‚  (è®¡åˆ’å¼€å‘)                          â”‚
â”‚  ç«¯å£: 3000       â”‚  ç«¯å£: 3001          â”‚  ç«¯å£: 3002                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                   HTTP/WebSocket
                                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          ğŸšª APIç½‘å…³å±‚ (Gateway Layer)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Nginxåå‘ä»£ç†    â”‚  è´Ÿè½½å‡è¡¡           â”‚  è®¤è¯æˆæƒ          â”‚  é™æµç†”æ–­         â”‚
â”‚  ç«¯å£: 80/443     â”‚  è½®è¯¢/æƒé‡          â”‚  JWTéªŒè¯           â”‚  Rate Limiting    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                   å†…éƒ¨è·¯ç”±è½¬å‘
                                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         âš™ï¸ å¾®æœåŠ¡å±‚ (Microservices Layer)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¸‚åœºæ•°æ®æœåŠ¡      â”‚ äº¤æ˜“å¼•æ“æœåŠ¡        â”‚ ç­–ç•¥å¼•æ“æœåŠ¡       â”‚ é£é™©ç®¡ç†æœåŠ¡      â”‚
â”‚ market-data       â”‚ trading-engine      â”‚ strategy-engine    â”‚ risk-management   â”‚
â”‚ ç«¯å£: 8081        â”‚ ç«¯å£: 8087          â”‚ ç«¯å£: 9001         â”‚ ç«¯å£: 8085        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç”¨æˆ·ç®¡ç†æœåŠ¡      â”‚ é€šçŸ¥æœåŠ¡            â”‚ åˆ†ææœåŠ¡           â”‚ AIæœåŠ¡            â”‚
â”‚ user-management   â”‚ notification        â”‚ analytics          â”‚ ai-service        â”‚
â”‚ ç«¯å£: 8083        â”‚ ç«¯å£: 8086          â”‚ ç«¯å£: 8088         â”‚ ç«¯å£: 8089        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                              æ•°æ®åº“è¿æ¥æ±  (tokio-postgres)
                                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          ğŸ’¾ æ•°æ®å­˜å‚¨å±‚ (Data Storage Layer)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PostgreSQL        â”‚ Redis              â”‚ ClickHouse         â”‚ Apache Kafka      â”‚
â”‚ ä¸šåŠ¡æ•°æ®          â”‚ ç¼“å­˜/ä¼šè¯          â”‚ æ—¶åºæ•°æ®           â”‚ æ¶ˆæ¯é˜Ÿåˆ—          â”‚
â”‚ ç«¯å£: 5432        â”‚ ç«¯å£: 6379         â”‚ ç«¯å£: 9000         â”‚ ç«¯å£: 9092        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                   å¤–éƒ¨APIè°ƒç”¨
                                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ğŸŒ å¤–éƒ¨æœåŠ¡å±‚ (External Services Layer)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Binance API       â”‚ OKX API            â”‚ Huobi API          â”‚ é‚®ä»¶/çŸ­ä¿¡æœåŠ¡     â”‚
â”‚ WebSocket/REST    â”‚ WebSocket/REST     â”‚ WebSocket/REST     â”‚ SMTP/SMS          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ **è¯¦ç»†æ•°æ®æµç¨‹åˆ†æ**

### 1ï¸âƒ£ **ç”¨æˆ·äº¤æ˜“è¯·æ±‚æµç¨‹**

```
ç”¨æˆ·æ“ä½œ â†’ å‰ç«¯éªŒè¯ â†’ APIç½‘å…³ â†’ å¾®æœåŠ¡å¤„ç† â†’ æ•°æ®åº“æ“ä½œ â†’ å¤–éƒ¨äº¤æ˜“æ‰€
   â†“         â†“         â†“         â†“           â†“           â†“
[ç‚¹å‡»ä¹°å…¥] [è¡¨å•æ ¡éªŒ] [JWTè®¤è¯] [é£é™©æ£€æŸ¥] [è®¢å•å…¥åº“] [äº¤æ˜“æ‰€ä¸‹å•]
```

#### ğŸ¯ **å…·ä½“æ­¥éª¤è¯¦è§£**

**Step 1: å‰ç«¯ç”¨æˆ·æ“ä½œ**
```typescript
// quant-backend66/components/Trading.tsx
const handleBuyOrder = async (orderData: OrderRequest) => {
  // 1. å‰ç«¯è¡¨å•éªŒè¯
  if (!validateOrderData(orderData)) {
    showError('è®¢å•æ•°æ®æ— æ•ˆ');
    return;
  }
  
  // 2. å‘é€APIè¯·æ±‚
  const response = await fetch('/api/trading/orders', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(orderData)
  });
}
```

**Step 2: APIç½‘å…³å¤„ç†**
```nginx
# Nginxé…ç½® - è¯·æ±‚è·¯ç”±
location /api/trading/ {
    proxy_pass http://localhost:8087/;  # trading-engineæœåŠ¡
    proxy_set_header Authorization $http_authorization;
    proxy_set_header X-Real-IP $remote_addr;
}
```

**Step 3: äº¤æ˜“å¼•æ“æœåŠ¡å¤„ç†**
```rust
// services/trading-engine/src/handlers/order.rs
pub async fn create_order(
    State(app_state): State<AppState>,
    Json(order_request): Json<OrderRequest>
) -> Result<Json<OrderResponse>, AppError> {
    
    // 1. JWTä»¤ç‰ŒéªŒè¯
    let user_id = verify_jwt_token(&token)?;
    
    // 2. è°ƒç”¨é£é™©ç®¡ç†æœåŠ¡
    let risk_check = risk_client
        .check_order_risk(&user_id, &order_request)
        .await?;
    
    if !risk_check.approved {
        return Err(AppError::RiskRejected(risk_check.reason));
    }
    
    // 3. æ•°æ®åº“æ“ä½œ
    let order = sqlx::query_as!(
        Order,
        "INSERT INTO orders (user_id, symbol, side, quantity, price) 
         VALUES ($1, $2, $3, $4, $5) RETURNING *",
        user_id, order_request.symbol, order_request.side,
        order_request.quantity, order_request.price
    )
    .fetch_one(&app_state.db_pool)
    .await?;
    
    // 4. å‘é€åˆ°äº¤æ˜“æ‰€
    let exchange_result = exchange_client
        .place_order(&order)
        .await?;
    
    Ok(Json(OrderResponse::from(order)))
}
```

**Step 4: æ•°æ®åº“æ“ä½œ**
```sql
-- PostgreSQL è®¢å•è¡¨æ“ä½œ
BEGIN;
  INSERT INTO orders (id, user_id, symbol, side, quantity, price, status, created_at)
  VALUES (gen_random_uuid(), $1, $2, $3, $4, $5, 'pending', NOW());
  
  UPDATE user_balances 
  SET available_balance = available_balance - $4 * $5
  WHERE user_id = $1 AND currency = 'USDT';
COMMIT;
```

**Step 5: å¤–éƒ¨äº¤æ˜“æ‰€è°ƒç”¨**
```rust
// å¸å®‰APIè°ƒç”¨ç¤ºä¾‹
pub async fn place_binance_order(order: &Order) -> Result<ExchangeOrderResponse> {
    let client = reqwest::Client::new();
    let params = BinanceOrderParams {
        symbol: order.symbol.clone(),
        side: order.side.to_string(),
        type_: "LIMIT".to_string(),
        quantity: order.quantity,
        price: order.price,
        timestamp: chrono::Utc::now().timestamp_millis(),
    };
    
    let signature = generate_signature(&params, &api_secret);
    
    let response = client
        .post("https://api.binance.com/api/v3/order")
        .header("X-MBX-APIKEY", &api_key)
        .json(&params)
        .query(&[("signature", signature)])
        .send()
        .await?;
        
    Ok(response.json().await?)
}
```

---

### 2ï¸âƒ£ **å®æ—¶æ•°æ®æµç¨‹**

```
äº¤æ˜“æ‰€WebSocket â†’ å¸‚åœºæ•°æ®æœåŠ¡ â†’ ClickHouseå­˜å‚¨ â†’ Kafkaåˆ†å‘ â†’ å‰ç«¯å®æ—¶æ›´æ–°
       â†“              â†“              â†“            â†“           â†“
   [ä»·æ ¼æ¨é€]     [æ•°æ®æ ‡å‡†åŒ–]    [æ—¶åºå­˜å‚¨]   [æ¶ˆæ¯é˜Ÿåˆ—]   [å›¾è¡¨æ›´æ–°]
```

#### ğŸ¯ **å®æ—¶æ•°æ®å¤„ç†è¯¦è§£**

**Step 1: äº¤æ˜“æ‰€WebSocketè¿æ¥**
```rust
// services/market-data/src/websocket/binance.rs
pub async fn connect_binance_stream() -> Result<()> {
    let url = "wss://stream.binance.com:9443/ws/btcusdt@ticker";
    let (ws_stream, _) = connect_async(url).await?;
    
    while let Some(msg) = ws_stream.next().await {
        match msg? {
            Message::Text(text) => {
                let tick_data: BinanceTickerData = serde_json::from_str(&text)?;
                process_market_tick(tick_data).await?;
            }
            _ => {}
        }
    }
    Ok(())
}
```

**Step 2: æ•°æ®æ ‡å‡†åŒ–å¤„ç†**
```rust
// services/market-data/src/processors/normalizer.rs
pub fn normalize_ticker_data(raw_data: BinanceTickerData) -> MarketTick {
    MarketTick {
        exchange: "binance".to_string(),
        symbol: raw_data.symbol,
        timestamp: raw_data.event_time,
        price: Decimal::from_str(&raw_data.close_price).unwrap(),
        volume: Decimal::from_str(&raw_data.volume).unwrap(),
        bid: Decimal::from_str(&raw_data.bid_price).unwrap(),
        ask: Decimal::from_str(&raw_data.ask_price).unwrap(),
    }
}
```

**Step 3: ClickHouseæ—¶åºå­˜å‚¨**
```rust
// services/market-data/src/storage/clickhouse.rs
pub async fn store_market_tick(tick: &MarketTick) -> Result<()> {
    let client = clickhouse::Client::default()
        .with_url("http://localhost:9000");
    
    client
        .query("INSERT INTO market_ticks VALUES")
        .bind(&tick.exchange)
        .bind(&tick.symbol)
        .bind(tick.timestamp)
        .bind(tick.price)
        .bind(tick.volume)
        .execute()
        .await?;
        
    Ok(())
}
```

**Step 4: Kafkaæ¶ˆæ¯åˆ†å‘**
```rust
// services/market-data/src/messaging/kafka.rs
pub async fn publish_market_update(tick: &MarketTick) -> Result<()> {
    let producer: FutureProducer = ClientConfig::new()
        .set("bootstrap.servers", "localhost:9092")
        .create()?;
    
    let payload = serde_json::to_string(tick)?;
    let record = FutureRecord::to("market-data")
        .key(&tick.symbol)
        .payload(&payload);
    
    producer.send(record, Duration::from_secs(0)).await?;
    Ok(())
}
```

**Step 5: å‰ç«¯WebSocketæ¥æ”¶**
```typescript
// quant-backend66/src/hooks/useWebSocket.ts
export const useMarketData = (symbol: string) => {
  const [price, setPrice] = useState<number>(0);
  
  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8081/ws/market-data');
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.symbol === symbol) {
        setPrice(data.price);
        // æ›´æ–°TradingViewå›¾è¡¨
        updateTradingViewChart(data);
      }
    };
    
    return () => ws.close();
  }, [symbol]);
  
  return { price };
};
```

---

### 3ï¸âƒ£ **ç”¨æˆ·è®¤è¯æµç¨‹**

```
ç™»å½•è¯·æ±‚ â†’ ç”¨æˆ·ç®¡ç†æœåŠ¡ â†’ æ•°æ®åº“éªŒè¯ â†’ JWTç”Ÿæˆ â†’ Redisç¼“å­˜ â†’ å‰ç«¯å­˜å‚¨
    â†“          â†“            â†“          â†“         â†“         â†“
[è¾“å…¥å¯†ç ]  [å¯†ç éªŒè¯]   [ç”¨æˆ·æŸ¥è¯¢]  [ä»¤ç‰Œç­¾å‘] [ä¼šè¯ç¼“å­˜] [æœ¬åœ°å­˜å‚¨]
```

#### ğŸ¯ **è®¤è¯æµç¨‹è¯¦è§£**

**Step 1: å‰ç«¯ç™»å½•è¯·æ±‚**
```typescript
// quant-backend66/src/services/auth.ts
export const login = async (credentials: LoginCredentials) => {
  const response = await fetch('/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(credentials)
  });
  
  const data = await response.json();
  
  if (data.token) {
    localStorage.setItem('auth_token', data.token);
    localStorage.setItem('user_info', JSON.stringify(data.user));
  }
  
  return data;
};
```

**Step 2: ç”¨æˆ·ç®¡ç†æœåŠ¡éªŒè¯**
```rust
// services/user-management/src/handlers/auth.rs
pub async fn login(
    State(app_state): State<AppState>,
    Json(login_request): Json<LoginRequest>
) -> Result<Json<LoginResponse>, AppError> {
    
    // 1. æ•°æ®åº“æŸ¥è¯¢ç”¨æˆ·
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE email = $1 AND status = 'active'",
        login_request.email
    )
    .fetch_optional(&app_state.db_pool)
    .await?;
    
    let user = user.ok_or(AppError::InvalidCredentials)?;
    
    // 2. å¯†ç éªŒè¯
    let is_valid = bcrypt::verify(&login_request.password, &user.password_hash)?;
    if !is_valid {
        return Err(AppError::InvalidCredentials);
    }
    
    // 3. ç”ŸæˆJWTä»¤ç‰Œ
    let claims = Claims {
        sub: user.id.to_string(),
        exp: (Utc::now() + Duration::hours(24)).timestamp() as usize,
        iat: Utc::now().timestamp() as usize,
        roles: user.roles.clone(),
    };
    
    let token = encode(&Header::default(), &claims, &ENCODING_KEY)?;
    
    // 4. Redisç¼“å­˜ä¼šè¯
    app_state.redis_client
        .setex(&format!("session:{}", user.id), 86400, &token)
        .await?;
    
    Ok(Json(LoginResponse {
        token,
        user: user.into(),
        expires_in: 86400,
    }))
}
```

---

### 4ï¸âƒ£ **AIæ™ºèƒ½åˆ†ææµç¨‹**

```
å¸‚åœºæ•°æ® â†’ AIæœåŠ¡ â†’ æ¨¡å‹æ¨ç† â†’ ç­–ç•¥ä¿¡å· â†’ äº¤æ˜“å»ºè®® â†’ å‰ç«¯å±•ç¤º
    â†“        â†“        â†“         â†“         â†“         â†“
[ä»·æ ¼æ•°æ®] [æ•°æ®é¢„å¤„ç†] [AIè®¡ç®—] [ä¿¡å·ç”Ÿæˆ] [é£é™©è¯„ä¼°] [ç”¨æˆ·ç•Œé¢]
```

#### ğŸ¯ **AIåˆ†æè¯¦è§£**

**Step 1: æ•°æ®è¾“å…¥**
```rust
// services/ai-service/src/data/collector.rs
pub async fn collect_market_features(symbol: &str) -> Result<MarketFeatures> {
    // ä»ClickHouseè·å–å†å²æ•°æ®
    let klines = clickhouse_client
        .query("SELECT * FROM klines WHERE symbol = ? ORDER BY open_time DESC LIMIT 100")
        .bind(symbol)
        .fetch_all()
        .await?;
    
    // è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
    let features = MarketFeatures {
        prices: klines.iter().map(|k| k.close).collect(),
        volumes: klines.iter().map(|k| k.volume).collect(),
        rsi: calculate_rsi(&klines),
        macd: calculate_macd(&klines),
        bollinger_bands: calculate_bollinger_bands(&klines),
    };
    
    Ok(features)
}
```

**Step 2: AIæ¨¡å‹æ¨ç†**
```rust
// services/ai-service/src/models/predictor.rs
pub async fn predict_price_movement(features: &MarketFeatures) -> Result<PredictionResult> {
    // ä½¿ç”¨è®­ç»ƒå¥½çš„æ¨¡å‹è¿›è¡Œé¢„æµ‹
    let model = load_model("price_prediction_model.onnx")?;
    
    let input_tensor = prepare_input_tensor(features)?;
    let output = model.run(vec![input_tensor])?;
    
    let prediction = PredictionResult {
        direction: if output[0] > 0.5 { Direction::Up } else { Direction::Down },
        confidence: output[0],
        target_price: features.current_price * (1.0 + output[1]),
        time_horizon: Duration::minutes(30),
    };
    
    Ok(prediction)
}
```

**Step 3: å‰ç«¯AIåŠ©æ‰‹å±•ç¤º**
```typescript
// quant-backend66/components/AI.tsx
export const AITradingAssistant = () => {
  const [aiSignals, setAiSignals] = useState<AISignal[]>([]);
  
  useEffect(() => {
    const fetchAISignals = async () => {
      const response = await fetch('/api/ai/signals/BTCUSDT');
      const signals = await response.json();
      setAiSignals(signals);
    };
    
    fetchAISignals();
    const interval = setInterval(fetchAISignals, 30000); // 30ç§’æ›´æ–°
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    <div className="ai-assistant">
      <h3>ğŸ¤– AIäº¤æ˜“åŠ©æ‰‹</h3>
      {aiSignals.map(signal => (
        <div key={signal.id} className="ai-signal">
          <span className={`signal-${signal.direction}`}>
            {signal.direction === 'up' ? 'ğŸ“ˆ' : 'ğŸ“‰'} 
            {signal.symbol}
          </span>
          <span>ç½®ä¿¡åº¦: {(signal.confidence * 100).toFixed(1)}%</span>
          <span>ç›®æ ‡ä»·: ${signal.target_price}</span>
        </div>
      ))}
    </div>
  );
};
```

---

## ğŸ” **å…³é”®æŠ€æœ¯èŠ‚ç‚¹åˆ†æ**

### ğŸš€ **æ€§èƒ½ä¼˜åŒ–èŠ‚ç‚¹**

1. **è¿æ¥æ± ç®¡ç†**
```rust
// æ•°æ®åº“è¿æ¥æ± é…ç½®
let pool = PgPoolOptions::new()
    .max_connections(20)
    .min_connections(5)
    .acquire_timeout(Duration::from_secs(3))
    .connect(&database_url)
    .await?;
```

2. **Redisç¼“å­˜ç­–ç•¥**
```rust
// å¤šçº§ç¼“å­˜
pub async fn get_user_info(user_id: &str) -> Result<User> {
    // L1: å†…å­˜ç¼“å­˜
    if let Some(user) = MEMORY_CACHE.get(user_id) {
        return Ok(user);
    }
    
    // L2: Redisç¼“å­˜
    if let Some(user_json) = redis.get(&format!("user:{}", user_id)).await? {
        let user: User = serde_json::from_str(&user_json)?;
        MEMORY_CACHE.insert(user_id.to_string(), user.clone());
        return Ok(user);
    }
    
    // L3: æ•°æ®åº“æŸ¥è¯¢
    let user = query_user_from_db(user_id).await?;
    
    // å›å†™ç¼“å­˜
    redis.setex(&format!("user:{}", user_id), 3600, 
               serde_json::to_string(&user)?).await?;
    MEMORY_CACHE.insert(user_id.to_string(), user.clone());
    
    Ok(user)
}
```

### ğŸ›¡ï¸ **å®‰å…¨æ§åˆ¶èŠ‚ç‚¹**

1. **JWTä¸­é—´ä»¶**
```rust
pub async fn jwt_middleware(
    mut req: Request<Body>,
    next: Next<Body>,
) -> Result<Response, StatusCode> {
    let auth_header = req.headers()
        .get("authorization")
        .and_then(|h| h.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    let token = auth_header.strip_prefix("Bearer ")
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    let claims = decode::<Claims>(token, &DECODING_KEY, &Validation::default())
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    req.extensions_mut().insert(claims.claims);
    Ok(next.run(req).await)
}
```

2. **é™æµæ§åˆ¶**
```rust
pub async fn rate_limit_middleware(
    req: Request<Body>,
    next: Next<Body>,
) -> Result<Response, StatusCode> {
    let client_ip = get_client_ip(&req);
    let key = format!("rate_limit:{}", client_ip);
    
    let current_count: i32 = redis.incr(&key, 1).await
        .unwrap_or(1);
    
    if current_count == 1 {
        redis.expire(&key, 60).await.ok();
    }
    
    if current_count > 100 {
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }
    
    Ok(next.run(req).await)
}
```

---

## ğŸ“Š **æ•°æ®æµé‡ç»Ÿè®¡**

### ğŸ“ˆ **å®æ—¶æ•°æ®æµé‡**
- **WebSocketè¿æ¥**: 8ä¸ªäº¤æ˜“æ‰€ Ã— 100ä¸ªäº¤æ˜“å¯¹ = 800ä¸ªè¿æ¥
- **æ•°æ®é¢‘ç‡**: å¹³å‡æ¯ç§’1000æ¡tickæ•°æ®
- **å­˜å‚¨é‡**: æ¯æ—¥çº¦8.64GBæ—¶åºæ•°æ®
- **ç¼“å­˜å‘½ä¸­ç‡**: Redisç¼“å­˜å‘½ä¸­ç‡ > 95%

### ğŸ’¾ **æ•°æ®åº“è´Ÿè½½**
- **PostgreSQL**: ä¸»è¦å¤„ç†ä¸šåŠ¡æ•°æ®ï¼ŒQPS < 1000
- **ClickHouse**: å¤„ç†æ—¶åºæ•°æ®ï¼Œå†™å…¥QPS > 10000
- **Redis**: ç¼“å­˜å’Œä¼šè¯ï¼ŒQPS > 5000

---

## ğŸ¯ **æ€»ç»“**

è¿™ä¸ªé‡åŒ–äº¤æ˜“å¹³å°çš„æ•°æ®æµç»è¿‡äº†ä»¥ä¸‹å…³é”®ç¯èŠ‚ï¼š

1. **å‰ç«¯äº¤äº’å±‚** - ç”¨æˆ·æ“ä½œå’Œæ•°æ®å±•ç¤º
2. **APIç½‘å…³å±‚** - è¯·æ±‚è·¯ç”±å’Œå®‰å…¨æ§åˆ¶  
3. **å¾®æœåŠ¡å±‚** - ä¸šåŠ¡é€»è¾‘å¤„ç†
4. **æ•°æ®å­˜å‚¨å±‚** - å¤šç§æ•°æ®åº“ååŒå·¥ä½œ
5. **å¤–éƒ¨æœåŠ¡å±‚** - äº¤æ˜“æ‰€å’Œç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆ

æ•´ä¸ªç³»ç»Ÿé€šè¿‡ç²¾å¿ƒè®¾è®¡çš„æ¶æ„ï¼Œå®ç°äº†é«˜æ€§èƒ½ã€é«˜å¯ç”¨ã€é«˜å®‰å…¨æ€§çš„é‡åŒ–äº¤æ˜“å¹³å°ã€‚